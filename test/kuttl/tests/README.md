# KUTTL Tests

The idea behind [kuttl](https://kuttl.dev/) tests is to cover part of the
`service` (and service `operator`) functionalities without the need to run an
e2e job with `tempest`. In particular, kuttl tests in this context are supposed
to cover the following aspects:
1. Ensure/Assert that the requested resources are generated by the operator
   when a target topology is deployed
2. Ensure service components can be scaled up, scaled down and cleaned up, and
   the operator works as expected when multiple replicas/APIs are deployed
3. Verify that particular backends configuration (in this case single vs
   multistore) can be deployed and CRUD operations are allowed

## Assumptions

Kuttl tests are based on the
[install_yamls](https://github.com/openstack-k8s-operators/install_yamls)
target that, in case of `Glance`, results in the following structure:

- a memcached instance, managed by
  [infra-operator](https://github.com/openstack-k8s-operators/infra-operator)
- a mariadb/galera instance, managed by
  [mariadb-operator](https://github.com/openstack-k8s-operators/mariadb-operator)
- a keystone instance, managed by
  [keystone-operator](https://github.com/openstack-k8s-operators/keystone-operator)
- a rabbitmq instance, managed by
  [cluster-operator](https://github.com/openstack-k8s-operators/rabbitmq-cluster-operator)
- a swift instance, managed by
  [swift-operator](https://github.com/openstack-k8s-operators/swift-operator)

The `openstack-operator` is not deployed in this context, as the goal is to test
this particular component without the extra complexity generated by other layers.

## Backend considerations

Other than asserting that the deployed topology matches the expectations,
it is possible to configure one or multiple backends to test particular
features. In the current kuttl tests, two backends are allowed and tested:

- `swift`, deployed and configured in the `split` use case. In general, when
  `ceph`, `cinder`, or`swift` are used as a backend, `Glance` is deployed in
  `split` mode, which means that the topology presents two `glanceAPI(s)`:
  the external API is used by cli and is associated with the public endpoint,
  the internal API is used by openstack services connected to glance (nova and
  cinder)

- `file`, deployed and configured in the `single` use case. `file` can be used
  to simulate the `NFS` backend, or to test topologies where the backend is not
  relevant (for instance it's used by `distributed-image-import`, where we test
  the interaction between two glanceAPI replicas, and there's no interest to
  see a specific backend behavior)
  For further information about the topologies and design choices, review the
  [dedicated section](https://github.com/openstack-k8s-operators/glance-operator/blob/main/docs/design-decisions.md).

## Available kuttl tests

The following kuttl tests are currently tested in CI:

- [glance_single](glance_single/)
- [glance_single_tls](glance_single_tls/)
- [glance_split](glance_split/)
- [glance_image_cache](glance_image_cache/)
- [glance_dist_image_import](glance_dist_image_import/README.md)

## Create a new kuttl test: guidelines

When writing kuttl tests in the `glance-operator`, there are a few established
guidelines to follow:

1. Each test must be prefixed with a number referred to the execution step
2. Each kuttl test must provide a **cleanup step** to delete all the generated
   resources
3. **Do not repeat** the same asserts already defined in other tests: this
   guideline is critical, it improves `readability` and helps with
   `maintenance`. When CI runs, the full test suite is executed and most of the
   asserts are already checked, hence code `deduplication` is a goal to achieve
   even in this scenario
4. When an assert is defined, make sure to include the relevant bits: check
   which part of the CR is meaningful for the sake of testing, and do not copy
   and paste the whole resulting CR. It might happen that due to a backend
   configuration or a particular parameter exposed by the API, the resulting CR
   is different (e.g., if cinder is set as a backend, the Pod definition is
   slightly different because it runs in `privileged mode`), so it's essential
   to have a clear idea of what should be tested and asserted, and all the
   other fields can be omitted by the CR
5. It is possible to execute `scripts` from a `kuttl` step: if there are
   multiple steps and the script logic can't fit a few lines of `bash`,
   consider adding a **dedicated script**. Within the executed script, make
   sure to properly manage the exit codes to avoid false positive or negative.
6. If the goal **is not** to test an operator capability, but rather a service
   functionality, run the test/script from the `glance cli` provided by the
   `openstackclient`. For this particular purpose it is possible to deploy an
   `openstackclient` `Pod` and load a set of scripts via the `configMapGenerator`
   defined in the
   [kustomization.yaml](https://github.com/openstack-k8s-operators/glance-operator/blob/main/config/samples/openstackclient/kustomization.yaml).
   See the [how to include the openstackclient in a kuttl
   test](../../../config/samples/openstackclient) section for further
   information
7. Add a `README.md` file within the new kuttl test directory and briefly
   explain the goal of the test, any potential assumptions (e.g. the number of
   replicas or API, the topology, the deployed resources and the backend(s))
   and the steps required to achieve the goal: this helps other people to
   better understand the purpose and have the right context.
